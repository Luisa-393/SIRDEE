<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Detección de Dígitos en Web</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://cdn.jsdelivr.net/npm/onnxruntime-web@1.18.0/dist/ort.min.js"></script>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Inter:wght@400;600;700&display=swap');
        body {
            font-family: 'Inter', sans-serif;
            background-color: #f3f4f6;
        }
        .container {
            max-width: 1200px;
        }
    </style>
</head>
<body class="bg-gray-100 flex items-center justify-center min-h-screen p-4">
    <div class="container bg-white rounded-xl shadow-lg p-6 flex flex-col lg:flex-row space-y-6 lg:space-y-0 lg:space-x-6">
        <!-- Panel Izquierdo: Resultados -->
        <div class="w-full lg:w-1/3 bg-gray-50 p-4 rounded-lg shadow-inner flex flex-col">
            <h2 class="text-xl font-bold mb-4 text-center text-gray-800">Resultados de Detección</h2>
            <div id="results-list" class="flex-grow overflow-y-auto bg-white rounded-md p-2 space-y-2 text-sm text-gray-700">
                <!-- Los resultados se insertarán aquí dinámicamente -->
            </div>
        </div>

        <!-- Panel Derecho: Controles y Visualización -->
        <div class="w-full lg:w-2/3 flex flex-col space-y-6">
            <!-- Controles -->
            <div class="bg-gray-50 p-4 rounded-lg shadow-inner">
                <div class="flex flex-col md:flex-row md:items-center md:space-x-4 mb-4">
                    <label class="block text-sm font-medium text-gray-700">Modelo ONNX cargado:</label>
                    <p class="mt-1 flex-grow p-1 text-sm text-gray-900 font-semibold">best.onnx</p>
                </div>
                <div class="flex flex-col md:flex-row md:items-center md:space-x-4 mb-4">
                    <label class="block text-sm font-medium text-gray-700">Fuente de video:</label>
                    <select id="video-source" class="mt-1 flex-grow p-1 border border-gray-300 rounded-md shadow-sm text-sm">
                        <option value="webcam">Cámara web</option>
                        <option value="file">Subir video local</option>
                    </select>
                    <input type="file" id="video-file-input" accept="video/*" class="mt-1 flex-grow p-1 border border-gray-300 rounded-md shadow-sm text-sm hidden">
                </div>
                <div class="flex flex-col md:flex-row md:items-center md:space-x-4 mb-4">
                    <label class="block text-sm font-medium text-gray-700">Intervalo de detección (ms):</label>
                    <input type="number" id="interval-input" value="500" class="mt-1 p-1 border border-gray-300 rounded-md shadow-sm w-full md:w-24 text-sm">
                </div>
                <div class="flex flex-col md:flex-row md:items-center md:space-x-4">
                    <button id="start-button" class="flex-grow bg-blue-500 hover:bg-blue-600 text-white font-semibold py-2 px-4 rounded-lg transition-colors shadow-md hidden">
                        Iniciar Detección
                    </button>
                    <button id="stop-button" class="flex-grow bg-red-500 hover:bg-red-600 text-white font-semibold py-2 px-4 rounded-lg transition-colors shadow-md hidden">
                        Detener Detección
                    </button>
                    <button id="reset-roi-button" class="flex-grow bg-gray-500 hover:bg-gray-600 text-white font-semibold py-2 px-4 rounded-lg transition-colors shadow-md hidden">
                        Reiniciar Área
                    </button>
                </div>
            </div>

            <!-- Visualización -->
            <div class="relative bg-black rounded-lg overflow-hidden shadow-xl">
                <video id="webcam-video" autoplay playsinline class="w-full h-full object-contain absolute hidden"></video>
                <canvas id="detection-canvas" class="w-full h-full block"></canvas>
                <div id="status-message" class="absolute bottom-0 left-0 right-0 bg-gray-800 bg-opacity-75 text-white p-2 text-center text-sm">
                    Cargando...
                </div>
            </div>
        </div>
    </div>

    <script>
        // Inicializar el entorno
        const webcamVideo = document.getElementById('webcam-video');
        const detectionCanvas = document.getElementById('detection-canvas');
        const context = detectionCanvas.getContext('2d');
        const startButton = document.getElementById('start-button');
        const stopButton = document.getElementById('stop-button');
        const intervalInput = document.getElementById('interval-input');
        const resultsList = document.getElementById('results-list');
        const statusMessage = document.getElementById('status-message');
        const videoSourceSelect = document.getElementById('video-source');
        const videoFileInput = document.getElementById('video-file-input');
        const resetRoiButton = document.getElementById('reset-roi-button');

        let session;
        let modelLoaded = false;
        let isRunning = false;
        let timeoutId;
        let frameCounter = 0;
        const allDigits = new Set();
        const modelUrl = './best.onnx';

        let modelConfig = {
            inputShape: [1, 3, 640, 640],
            outputShape: null,
            classNames: ['0', '1', '2', '3', '4', '5', '6', '7', '8', '9']
        };

        // Variables para la selección de la región de interés (ROI)
        let roi = null;
        let isDrawing = false;
        let startPoint = { x: 0, y: 0 };

        // Función para mostrar mensajes de estado
        function updateStatus(message, isError = false) {
            statusMessage.textContent = message;
            statusMessage.style.backgroundColor = isError ? 'rgba(220, 38, 38, 0.75)' : 'rgba(31, 41, 55, 0.75)';
        }

        // --- Configuración de la Cámara y el Canvas ---
        async function setupVideoSource() {
            stopDetection();
            webcamVideo.srcObject = null;
            webcamVideo.src = '';
            
            const source = videoSourceSelect.value;
            if (source === 'webcam') {
                videoFileInput.classList.add('hidden');
                try {
                    const stream = await navigator.mediaDevices.getUserMedia({ video: { facingMode: 'environment' } });
                    webcamVideo.srcObject = stream;
                    webcamVideo.onloadedmetadata = () => {
                        webcamVideo.play();
                        detectionCanvas.width = webcamVideo.videoWidth;
                        detectionCanvas.height = webcamVideo.videoHeight;
                        drawVideoFrame();
                        initializeApp();
                    };
                } catch (err) {
                    updateStatus('Error al acceder a la cámara: ' + err, true);
                    console.error("Error accessing webcam: ", err);
                }
            } else if (source === 'file') {
                videoFileInput.classList.remove('hidden');
                updateStatus('Por favor, sube un archivo de video para continuar.');
                startButton.classList.add('hidden');
            }
        }

        videoSourceSelect.addEventListener('change', setupVideoSource);

        videoFileInput.addEventListener('change', (event) => {
            if (event.target.files.length > 0) {
                const file = event.target.files[0];
                const fileURL = URL.createObjectURL(file);
                webcamVideo.src = fileURL;
                webcamVideo.onloadedmetadata = () => {
                    webcamVideo.play();
                    detectionCanvas.width = webcamVideo.videoWidth;
                    detectionCanvas.height = webcamVideo.videoHeight;
                    drawVideoFrame();
                    initializeApp();
                };
            }
        });

        async function initializeApp() {
            updateStatus('Cámara/Video listo. Cargando modelo ONNX...');
            await loadModel(modelUrl);
        }

        function drawVideoFrame() {
            if (!isRunning) {
                context.drawImage(webcamVideo, 0, 0, detectionCanvas.width, detectionCanvas.height);
                drawRoiBox();
                requestAnimationFrame(drawVideoFrame);
            }
        }

        function drawRoiBox() {
            if (roi) {
                context.strokeStyle = 'rgba(255, 0, 0, 0.8)';
                context.lineWidth = 2;
                context.strokeRect(roi.x, roi.y, roi.width, roi.height);
                context.fillStyle = 'rgba(255, 0, 0, 0.2)';
                context.fillRect(roi.x, roi.y, roi.width, roi.height);
                
                context.fillStyle = '#ff0000';
                context.font = '16px Inter';
                context.fillText('Área de Detección', roi.x, roi.y - 10);
            }
        }

        // --- Carga y Procesamiento del Modelo ONNX ---
        async function loadModel(url) {
            try {
                session = await ort.InferenceSession.create(url);
                console.log("Model loaded:", session.outputNames);
                modelLoaded = true;
                updateStatus('Modelo cargado. Arrastra el ratón para definir el área de detección.');
                resetRoiButton.classList.remove('hidden');
            } catch (e) {
                updateStatus('Error al cargar el modelo: ' + e.message, true);
                console.error('Error loading model:', e);
            }
        }

        // Preprocesamiento de la imagen para el modelo YOLOv8
        function preprocess(source, roi) {
            const [modelWidth, modelHeight] = [modelConfig.inputShape[2], modelConfig.inputShape[3]];
            
            // Crea un canvas temporal para el preprocesamiento
            const tempCanvas = document.createElement('canvas');
            const tempContext = tempCanvas.getContext('2d');
            tempCanvas.width = modelWidth;
            tempCanvas.height = modelHeight;
            
            // Dibuja el ROI del video en el canvas temporal, reescalando a 640x640
            tempContext.drawImage(source, roi.x, roi.y, roi.width, roi.height, 0, 0, modelWidth, modelHeight);
            
            const imageData = tempContext.getImageData(0, 0, modelWidth, modelHeight);
            const data = imageData.data;
            const float32Data = new Float32Array(modelWidth * modelHeight * 3);
            let i = 0;
            let j = 0;
            while (i < data.length) {
                float32Data[j] = data[i] / 255.0;
                float32Data[j + modelWidth * modelHeight] = data[i + 1] / 255.0;
                float32Data[j + modelWidth * modelHeight * 2] = data[i + 2] / 255.0;
                i += 4;
                j++;
            }
            return new ort.Tensor('float32', float32Data, modelConfig.inputShape);
        }

        // Postprocesamiento de los resultados de la inferencia
        function postprocess(output, threshold = 0.5) {
            const [rows, cols] = [output.dims[2], output.dims[1]];
            const boxes = [];
            const data = output.data;

            for (let i = 0; i < rows; i++) {
                const confidence = data[i * cols + 4];
                if (confidence >= threshold) {
                    const classScores = data.slice(i * cols + 5, i * cols + cols);
                    const classId = classScores.reduce((bestIndex, score, index) => score > classScores[bestIndex] ? index : bestIndex, 0);
                    const classConf = classScores[classId];

                    if (classConf >= threshold) {
                        const x = data[i * cols];
                        const y = data[i * cols + 1];
                        const w = data[i * cols + 2];
                        const h = data[i * cols + 3];

                        const x1 = x - w / 2;
                        const y1 = y - h / 2;
                        const x2 = x + w / 2;
                        const y2 = y + h / 2;
                        
                        // Calcular el área para ordenar por tamaño
                        const area = w * h;

                        boxes.push({ x1, y1, x2, y2, width: w, height: h, area, classId, confidence: classConf });
                    }
                }
            }
            return boxes;
        }

        // --- Bucle de Detección Principal ---
        async function detectionLoop() {
            if (!isRunning || !roi) return;

            const inputTensor = preprocess(webcamVideo, roi);
            const inputName = session.inputNames[0];
            const outputNames = session.outputNames;

            try {
                const results = await session.run({ [inputName]: inputTensor });
                const outputTensor = results[outputNames[0]];
                let detectedBoxes = postprocess(outputTensor);
                
                context.drawImage(webcamVideo, 0, 0, detectionCanvas.width, detectionCanvas.height);
                drawRoiBox();

                // Filtrar las cajas para mostrar solo las que están completamente dentro del ROI
                detectedBoxes = detectedBoxes.filter(box => {
                    const [modelWidth, modelHeight] = [modelConfig.inputShape[2], modelConfig.inputShape[3]];
                    const scaleX = roi.width / modelWidth;
                    const scaleY = roi.height / modelHeight;

                    // Convertir las coordenadas del modelo a las coordenadas del canvas
                    const x1 = roi.x + box.x1 * scaleX;
                    const y1 = roi.y + box.y1 * scaleY;
                    const x2 = roi.x + box.x2 * scaleX;
                    const y2 = roi.y + box.y2 * scaleY;

                    return x1 >= roi.x && y1 >= roi.y && x2 <= (roi.x + roi.width) && y2 <= (roi.y + roi.height);
                });


                // Ordenar las detecciones por tamaño de caja (área) de forma descendente
                detectedBoxes.sort((a, b) => b.area - a.area);
                
                // Limitar a los 6 dígitos más grandes
                detectedBoxes = detectedBoxes.slice(0, 6);

                // Ordenar las detecciones restantes de izquierda a derecha
                detectedBoxes.sort((a, b) => a.x1 - b.x1);
                
                let detectedString = '';

                detectedBoxes.forEach(box => {
                    const [modelWidth, modelHeight] = [modelConfig.inputShape[2], modelConfig.inputShape[3]];
                    const scaleX = roi.width / modelWidth;
                    const scaleY = roi.height / modelHeight;
                    
                    // Convertir las coordenadas del modelo a las coordenadas del canvas
                    const x1 = roi.x + box.x1 * scaleX;
                    const y1 = roi.y + box.y1 * scaleY;
                    const width = (box.x2 - box.x1) * scaleX;
                    const height = (box.y2 - box.y1) * scaleY;

                    // Dibuja el recuadro
                    context.strokeStyle = '#00ff00';
                    context.lineWidth = 2;
                    context.strokeRect(x1, y1, width, height);

                    // Dibuja el texto
                    const classId = box.classId;
                    const digit = modelConfig.classNames ? modelConfig.classNames[classId] : classId;
                    const conf = box.confidence.toFixed(2);
                    context.fillStyle = '#ff0000';
                    context.font = '20px Inter';
                    context.fillText(`${digit} (${conf})`, x1, y1 - 10);
                    
                    detectedString += digit;
                    allDigits.add(digit);
                });

                // Actualizar la lista de resultados con la cadena de dígitos
                const listItem = document.createElement('p');
                listItem.textContent = `Frame ${frameCounter}: ${detectedString.length > 0 ? detectedString : 'Ninguno'}`;
                resultsList.prepend(listItem);

                while (resultsList.children.length > 50) {
                    resultsList.lastChild.remove();
                }

                frameCounter++;
                updateStatus(`Detectando... Dígitos totales: ${Array.from(allDigits).join(', ')}`);

            } catch (e) {
                console.error("Error during inference: ", e);
                updateStatus('Error durante la detección: ' + e.message, true);
                stopDetection();
            }

            timeoutId = setTimeout(detectionLoop, parseInt(intervalInput.value));
        }

        // --- Control de la ROI (Región de Interés) ---
        detectionCanvas.addEventListener('mousedown', (e) => {
            if (!modelLoaded || isRunning) return;
            isDrawing = true;
            const rect = detectionCanvas.getBoundingClientRect();
            startPoint.x = e.clientX - rect.left;
            startPoint.y = e.clientY - rect.top;
        });

        detectionCanvas.addEventListener('mousemove', (e) => {
            if (!isDrawing) return;
            const rect = detectionCanvas.getBoundingClientRect();
            const currentX = e.clientX - rect.left;
            const currentY = e.clientY - rect.top;

            const x = Math.min(startPoint.x, currentX);
            const y = Math.min(startPoint.y, currentY);
            const width = Math.abs(currentX - startPoint.x);
            const height = Math.abs(currentY - startPoint.y);

            roi = { x, y, width, height };

            context.drawImage(webcamVideo, 0, 0, detectionCanvas.width, detectionCanvas.height);
            drawRoiBox();
        });

        detectionCanvas.addEventListener('mouseup', () => {
            if (!isDrawing) return;
            isDrawing = false;
            if (roi && roi.width > 10 && roi.height > 10) {
                startButton.classList.remove('hidden');
                updateStatus('Área de detección definida. Haz clic en "Iniciar" para comenzar.');
            } else {
                roi = null;
                startButton.classList.add('hidden');
                updateStatus('Área de detección no válida. Inténtalo de nuevo.');
            }
        });
        
        resetRoiButton.addEventListener('click', () => {
            roi = null;
            startButton.classList.add('hidden');
            stopDetection();
            updateStatus('Área de detección reiniciada. Dibuja un nuevo recuadro.');
        });


        // --- Control de Eventos de la Detección ---
        startButton.addEventListener('click', () => {
            if (modelLoaded && !isRunning && roi) {
                isRunning = true;
                startButton.classList.add('hidden');
                stopButton.classList.remove('hidden');
                webcamVideo.classList.add('hidden');
                detectionCanvas.classList.remove('hidden');
                detectionLoop();
            }
        });

        stopButton.addEventListener('click', () => {
            stopDetection();
        });
        
        webcamVideo.addEventListener('ended', () => {
            stopDetection();
            updateStatus(`Proceso de video finalizado. Dígitos totales: ${Array.from(allDigits).join(', ')}`);
        });

        function stopDetection() {
            if (isRunning) {
                isRunning = false;
                clearTimeout(timeoutId);
                startButton.classList.remove('hidden');
                stopButton.classList.add('hidden');
                webcamVideo.classList.remove('hidden');
                updateStatus(`Proceso detenido. Dígitos totales: ${Array.from(allDigits).join(', ')}`);
            }
        }

        // Inicializar la aplicación
        setupVideoSource();
    </script>
</body>
</html>
